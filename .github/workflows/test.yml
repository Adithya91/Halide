name: Build+Test
on:
  pull_request:
    types: [opened, synchronize, reopened, edited, review_requested]

jobs:
  test:
    name: ${{matrix.config.name}}
    runs-on: ${{matrix.config.os}}

    strategy:
      fail-fast: false  # Keep running other jobs even if one fails
      matrix:
        config:
        # Ubuntu (x86-64) builds
        # - {
        #     name: "Ubuntu g++ llvm8 cmake_shared",
        #     build_tool: "cmake_shared",
        #     cc: "gcc",
        #     cxx: "g++",
        #     llvm_version: 8,
        #     os: ubuntu-18.04,
        #   }
        # - {
        #     name: "Ubuntu g++ llvm8 cmake_static",
        #     build_tool: "cmake_static",
        #     cc: "gcc",
        #     cxx: "g++",
        #     llvm_version: 8,
        #     os: ubuntu-18.04,
        #   }
        # - {
        #     name: "Ubuntu g++ llvm8 make",
        #     build_tool: "make",
        #     cc: "gcc",
        #     cxx: "g++",
        #     llvm_version: 8,
        #     os: ubuntu-18.04,
        #   }
        - {
            name: "Ubuntu g++ llvm9 cmake_shared",
            build_tool: "cmake_shared",
            cc: "gcc",
            cxx: "g++",
            llvm_version: 9,
            os: ubuntu-18.04,
          }
        # - {
        #     name: "Ubuntu g++ llvm9 cmake_static",
        #     build_tool: "cmake_static",
        #     cc: "gcc",
        #     cxx: "g++",
        #     llvm_version: 9,
        #     os: ubuntu-18.04,
        #   }
        - {
            name: "Ubuntu g++ llvm9 make",
            build_tool: "make",
            cc: "gcc",
            cxx: "g++",
            llvm_version: 9,
            os: ubuntu-18.04,
          }

        # OSX builds
        - {
            name: "OSX llvm9 cmake_shared",
            build_tool: "cmake_shared",
            cc: "clang",
            cxx: "clang++",
            llvm_version: 9,
            os: macos-latest,
          }

        # - {
        #     name: "OSX llvm9 make",
        #     build_tool: "make",
        #     cc: "clang",
        #     cxx: "clang++",
        #     llvm_version: 9,
        #     os: macos-latest,
        #   }

        - {
            name: "MSVC llvm9 cmake_shared",
            build_tool: "cmake_shared",
            cc: "cl",
            cxx: "cl",
            llvm_version: 9,
            os: windows-latest,
            cmake_gen: "Visual Studio 16",
            cmake_arch: "x64",
            #environment_script: "C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Auxiliary/Build/vcvars64.bat",
          }

        # - {
        #     name: "Windows Latest MinGW", artifact: "Windows-MinGW.tar.xz",
        #     os: windows-latest,
        #     build_type: "Release", cc: "gcc", cxx: "g++"
        #   }

    steps:
    - uses: actions/checkout@v2
      with:
        path: 'halide'

    - name: Configure Ubuntu
      if: matrix.config.os == 'ubuntu-18.04'
      run: |
        sudo apt-get update

        # The standard Bionic install has gcc 7.4, which is known to be
        # buggy with LLVM. Use gcc 8 instead.
        # sudo apt-get install gcc-8 g++-8
        # sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 100
        # sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-8 100

        # Install OpenGL
        # TODO(srj): OpenGL is only needed to build the opengl tests (which we don't even run)...
        sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev

        # Install libpng
        sudo apt-get -y --force-yes install libpng-dev

        # Install doxygen
        sudo apt-get -y --force-yes --no-install-recommends install doxygen


    - name: Configure OSX
      if: matrix.config.os == 'macos-latest'
      run: |
        # Install libpng, jpeg, doxygen
        brew install libpng jpeg doxygen

        # Don't install LLVM via brew: it can conflict with the existing LLVM
        # installation in OSX and cause unhappiness. We'll handle it specially below.

    - name: Configure Windows
      if: matrix.config.os == 'windows-latest'
      shell: cmake -P {0}
      run: |
        # Install libpng, jpeg, doxygen
        # choco install libpng -- TBD, not on choco?
        # choco install libjpeg-turbo
        # choco install doxygen.install

    - name: Configure Env Vars (Windows)
      if: matrix.config.os == 'windows-latest'
      shell: powershell
      run: |
        # PowerShell script to set the MSVC env vars globally for all the steps in our job.
        # Adapted from https://github.com/microsoft/vswhere/wiki/Start-Developer-Command-Prompt
        # (No, I don't know PowerShell; this is heavily cargo-culted.)
        $arch = "x64"
        $hostArch = "x64"
        $vswherePath = "C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe"
        $vsInstallationPath = & "$vswherePath" -latest -property installationPath
        $vsDevCmdPath = "`"$vsInstallationPath\Common7\Tools\VsDevCmd.bat`""
        $command = "$vsDevCmdPath -no_logo -arch=$arch -host_arch=$hostArch"

        & "${env:COMSPEC}" /s /c "$command && set" | ForEach-Object {
          $name, $value = $_ -split '=', 2
          Write-Output "::set-env name=$name::$value"
        }

        # # See: https://github.com/microsoft/vswhere/wiki/Start-Developer-Command-Prompt
        # set(VSWHERE "C:/Program Files (x86)/Microsoft Visual Studio/Installer/vswhere.exe")
        # execute_process(
        #   COMMAND "${VSWHERE}" -latest -property installationPath
        #   OUTPUT_VARIABLE VS_INSTALLATION_PATH
        #   RESULT_VARIABLE result
        # )
        # if (NOT result EQUAL 0)
        #   message(FATAL_ERROR "Bad exit status: ${result}")
        # endif()
        # string(STRIP VS_INSTALLATION_PATH "${VS_INSTALLATION_PATH}")   # strip whitespace from start & end
        # string(REPLACE "\n" "" VS_INSTALLATION_PATH "${VS_INSTALLATION_PATH}")
        # string(REPLACE "\\" "/" ${{runner.temp}} "${TEMP}")
        # execute_process(
        #   COMMAND "${VS_INSTALLATION_PATH}/Common7/Tools/VsDevCmd.bat" -no_logo -arch=x64 -host_arch=x64 && set
        #   OUTPUT_FILE "${TEMP}/vc_env_vars.txt"
        #   RESULT_VARIABLE result
        # )
        # if (NOT result EQUAL 0)
        #   message(FATAL_ERROR "Bad exit status: ${result}")
        # endif()
        # file(STRINGS "${TEMP}/vc_env_vars.txt" ENV_LINES)
        # foreach(line IN LISTS ENV_LINES)
        #   message(STATUS "line is: ${line}")
        #   if (line MATCHES "^([a-zA-Z0-9_-]+)=(.*)$")
        #     # This is magic that GitHub Actions uses to allow global env var setting
        #     message(STATUS "::set-env name=${CMAKE_MATCH_1}::${CMAKE_MATCH_2}")
        #   endif()
        # endforeach()

    - name: Configure Env Vars
      shell: cmake -P {0}
      run: |
        set(ENV{CC} "${{matrix.config.cc}}")
        set(ENV{CXX} "${{matrix.config.cxx}}")
        set(ENV{LLVM_CONFIG} "${LLVM_DIR}/bin/llvm-config")

    - name: Download LLVM (Non-Windows)
      if: matrix.config.os != 'windows-latest'
      shell: cmake -P {0}
      run: |
        # Download LLVM Release.
        # Use CMake (rather than wget) because we know it's available and will get the job done.
        if("${{matrix.config.os}}" MATCHES "^ubuntu.*")
          set(LLVM_URL "https://releases.llvm.org/${{matrix.config.llvm_version}}.0.0/clang+llvm-${{matrix.config.llvm_version}}.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz")
        elseif("${{matrix.config.os}}" MATCHES "^macos.*")
          set(LLVM_URL "https://releases.llvm.org/${{matrix.config.llvm_version}}.0.0/clang+llvm-${{matrix.config.llvm_version}}.0.0-x86_64-darwin-apple.tar.xz")
        else()
          message(FATAL_ERROR "Unknown OS: ${{matrix.config.os}}")
        endif()

        set(ROOT "$ENV{GITHUB_WORKSPACE}")
        string(REPLACE "\\" "/" ROOT "${ROOT}")

        file(DOWNLOAD "${LLVM_URL}" "${ROOT}/llvm-project.tar.xz")
        execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf "${ROOT}/llvm-project.tar.xz")
        execute_process(COMMAND ${CMAKE_COMMAND} -E remove -f "${ROOT}/llvm-project.tar.xz")

        string(REGEX REPLACE
          "http[s]*://releases.llvm.org/[0-9\\.]*/([^/]*)\\.tar\\.xz"
          "\\1"
          LLVM_UNTAR_DIR
          "${LLVM_URL}"
        )
        message(STATUS "LLVM_UNTAR_DIR ${ROOT}/${LLVM_UNTAR_DIR}")
        execute_process(
          COMMAND ${CMAKE_COMMAND}
            -E rename "${ROOT}/${LLVM_UNTAR_DIR}" "${ROOT}/llvm"
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status: ${result}")
        endif()

    - name: Download LLVM (Windows)
      if: matrix.config.os == 'windows-latest'
      shell: cmake -P {0}
      run: |
        set(LLVM_URL "https://releases.llvm.org/${{matrix.config.llvm_version}}.0.0/LLVM-${{matrix.config.llvm_version}}.0.0-win64.exe")

        set(ROOT "$ENV{GITHUB_WORKSPACE}")
        string(REPLACE "\\" "/" ROOT "${ROOT}")

        file(DOWNLOAD "${LLVM_URL}" "${ROOT}/llvm.exe")
        # Note that the Windows VMs run as admin with UAC disabled; otherwise, this wouldn't work
        execute_process(
          COMMAND "${ROOT}/llvm.exe" "/S" "/D${ROOT}\\llvm"
          WORKING_DIRECTORY ${ROOT}
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status: ${result}")
        endif()

    - name: Configure Make
      if: startsWith(matrix.config.build_tool, 'make')
      shell: cmake -P {0}
      run: |
        # Configure Make
        set(ROOT "$ENV{GITHUB_WORKSPACE}")
        string(REPLACE "\\" "/" ROOT "${ROOT}")

        set(HALIDE_DIR "${ROOT}/halide")
        set(LLVM_DIR "${ROOT}/llvm")
        set(HALIDE_BUILD_DIR "${ROOT}/halide_build")

        execute_process(
          COMMAND ${CMAKE_COMMAND}
            -E make_directory "${HALIDE_BUILD_DIR}"
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status: ${result}")
        endif()


    - name: Configure CMake
      if: startsWith(matrix.config.build_tool, 'cmake')
      shell: cmake -P {0}
      run: |
        # Configure CMake
        set(ROOT "$ENV{GITHUB_WORKSPACE}")
        string(REPLACE "\\" "/" ROOT "${ROOT}")

        set(HALIDE_DIR "${ROOT}/halide")
        set(LLVM_DIR "${ROOT}/llvm")
        set(HALIDE_BUILD_DIR "${ROOT}/halide_build")

        execute_process(
          COMMAND ${CMAKE_COMMAND}
            -E make_directory "${HALIDE_BUILD_DIR}"
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status: ${result}")
        endif()

        if (NOT "${{matrix.config.cmake_gen}}" STREQUAL "")
          set(CMAKE_GEN "${{matrix.config.cmake_gen}}")
        else()
          set(CMAKE_GEN "Unix Makefiles")
        endif()

        if (NOT "${{matrix.config.cmake_arch}}" STREQUAL "")
          set(CMAKE_ARCH "${{matrix.config.cmake_arch}}")
        else()
          set(CMAKE_ARCH "")
        endif()

        if (${{matrix.config.build_tool}} MATCHES "cmake_shared")
          set(HALIDE_SHARED_LIBRARY ON)
        elseif (${{matrix.config.build_tool}} MATCHES "cmake_static")
          set(HALIDE_SHARED_LIBRARY OFF)
        else()
          message(FATAL_ERROR "Unknown build_tool: ${{matrix.config.build_tool}}")
        endif()

        message(STATUS "LLVM_DIR: ${LLVM_DIR}")
        message(STATUS "CMAKE_MODULE_PATH: ${CMAKE_MODULE_PATH}")
        message(STATUS "HALIDE_SHARED_LIBRARY: ${HALIDE_SHARED_LIBRARY}")
        message(STATUS "CMAKE_GEN: ${CMAKE_GEN}")
        message(STATUS "CMAKE_ARCH: ${CMAKE_ARCH}")
        message(STATUS "HALIDE_DIR: ${HALIDE_DIR}")

        # Make sure that our LLVM package is in CMAKE_MODULE_PATH
        # so that CMake will be able to find it
        execute_process(
          COMMAND ${CMAKE_COMMAND}
                  -DCMAKE_BUILD_TYPE=Release
                  -DLLVM_DIR="${LLVM_DIR}/lib/cmake/llvm/"
                  -DCMAKE_MODULE_PATH="${LLVM_DIR}/lib/cmake/llvm/;${CMAKE_MODULE_PATH}"
                  -DHALIDE_REQUIRE_LLVM_VERSION=${{matrix.config.llvm_version}}0
                  -DHALIDE_SHARED_LIBRARY=${HALIDE_SHARED_LIBRARY}
                  -G "${CMAKE_GEN}"
                  -A "${CMAKE_ARCH}"
                  "${HALIDE_DIR}"
          WORKING_DIRECTORY ${HALIDE_BUILD_DIR}
          RESULT_VARIABLE result
        )

        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status: ${result}")
        endif()

    - name: Build Halide
      shell: cmake -P {0}
      run: |
        # Build Halide
        set(ROOT "$ENV{GITHUB_WORKSPACE}")
        string(REPLACE "\\" "/" ROOT "${ROOT}")

        set(HALIDE_DIR "${ROOT}/halide")
        set(LLVM_DIR "${ROOT}/llvm")
        set(HALIDE_BUILD_DIR "${ROOT}/halide_build")

        set(PARALLEL_JOBS 4)  # The VMs have 2 cores, so specify N+2
        if (${{matrix.config.build_tool}} MATCHES "^cmake.*")
          foreach(TARGET all package)
            # CMake only allows one --target flag per invocation
            execute_process(
              COMMAND ${CMAKE_COMMAND} --build ${HALIDE_BUILD_DIR} -j ${PARALLEL_JOBS} --target ${TARGET}
              WORKING_DIRECTORY ${HALIDE_BUILD_DIR}
              RESULT_VARIABLE result
            )
            if (NOT result EQUAL 0)
              message(FATAL_ERROR "Bad exit status: ${result}")
            endif()
          endforeach()
        elseif (${{matrix.config.build_tool}} STREQUAL "make")
          execute_process(
            COMMAND make -f ${HALIDE_DIR}/Makefile -j ${PARALLEL_JOBS} distrib build_tests test_internal
            WORKING_DIRECTORY ${HALIDE_BUILD_DIR}
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status: ${result}")
          endif()
        else()
          message(FATAL_ERROR "Unknown build_tool: ${{matrix.config.build_tool}}")
        endif()

    - name: Run Tests
      shell: cmake -P {0}
      run: |
        set(ROOT "$ENV{GITHUB_WORKSPACE}")
        string(REPLACE "\\" "/" ROOT "${ROOT}")

        set(HALIDE_DIR "${ROOT}/halide")
        set(LLVM_DIR "${ROOT}/llvm")
        set(HALIDE_BUILD_DIR "${ROOT}/halide_build")

        # set TEST_TMPDIR for the tests that need it
        set(ENV{TEST_TMPDIR} "${{runner.temp}}")

        set(PARALLEL_JOBS 4)  # The VMs have 2 cores, so specify N+2
        if (${{matrix.config.build_tool}} MATCHES "^cmake.*")
          set(TEST_GROUPS_BROKEN "opengl")
          set(TEST_GROUPS_SERIAL "performance|auto_schedule")

          # Parallel
          execute_process(
            COMMAND ${CMAKE_CTEST_COMMAND} -j ${PARALLEL_JOBS} -LE "${TEST_GROUPS_BROKEN}|${TEST_GROUPS_SERIAL}" --output-on-failure
            WORKING_DIRECTORY ${HALIDE_BUILD_DIR}
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status: ${result}")
          endif()

          # Serial
          execute_process(
            COMMAND ${CMAKE_CTEST_COMMAND} -L "${TEST_GROUPS_SERIAL}" --output-on-failure
            WORKING_DIRECTORY ${HALIDE_BUILD_DIR}
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status: ${result}")
          endif()
        elseif (${{matrix.config.build_tool}} STREQUAL "make")
          execute_process(
            COMMAND make -f ${HALIDE_DIR}/Makefile -j ${PARALLEL_JOBS} run_tests
            WORKING_DIRECTORY ${HALIDE_BUILD_DIR}
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status: ${result}")
          endif()
        else()
          message(FATAL_ERROR "Unknown build_tool: ${{matrix.config.build_tool}}")
        endif()
